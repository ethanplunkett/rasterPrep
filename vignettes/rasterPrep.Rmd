---
title: "Preparing raster files for modeling or viewing"
author: "Ethan Plunkett"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{rasterPrep}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# rasterPrep 

The rasterPrep package fills two distinct needs:

1. Create fully aligned raster files for modeling, and analysis, from raster or
vector data.

2. Prepares output from models fo viewing in GIS software by humans.


### Installation

```{r install, eval = FALSE}
if(!require("remotes"))
  install.packages("remotes") 
library("remotes")
remotes::install_github("ethanplunkett/rasterPrep")
```

## I. Preparing rasters for modeling

This section walks through the process of preparing raster data for modeling.

The first step in many raster based GIS analyses is creating a series of 
raster files that coincide perfectly. That is they have identical resolutions, 
cell alignments, coordinate reference systems (crs), and extents. 

Typically, the source data is a mix of raster and vector files that do not 
coincide. This workflow demonstrates how convert disperate source data
inot a set of aligned TIFF files.

Overview:

1. Load packages and setup paths
2. Create a reference raster file with `makeRefence()`
3. Use `warpToReference()` to make existing rasters coincide with the reference
4. Use `rasterizeToReference()` to convert vector data to rasters that coincide 
with the reference, or overlay vector data on raster data.

### 1. Load packages and setup paths

#### Input paths

Four example files are included with the **rasterPrep** package.

1.  `input$bound`, *"Amherst.shp"*:  The polygon boundary for the Town of Amherst, MA extracted from here:
https://docs.digital.mass.gov/dataset/massgis-data-community-boundaries-towns
It is in Mass Mainland mass state plain projection  ([EPSG:26986](https://epsg.io/26986)).
This defines our study area and output projection.

2. `input$slope`, *"slope.tif"*: A raster clipped from https://scholarworks.umass.edu/data/17/ with 
the original projection and cell alignment preserved.  It is in the USA Contiguous Albers Equal Area Conic Projection([ESRI:202003](https://epsg.io/102003)).

3. `input$roads`, *"roads.shp"*: A Shapefile containing vector roads, originally from Open Street map but with small roads removed and clipped to Amherst.  It's in the same projection as 2. 

4. `input$key`, *"roadClassKey.csv"*: A csv file with columns "value" , "category", and "color", representing integer values, associated road class names, and a hexadecimal color that should be used for rendering (#rrggbb).

#### Output files:

1.  `out$ref`, *"reference.tif"*  A reference file used to define the extent, 
CRS, cellsize, and cell alignment, this is created first and then all other
files are aligned to it.

2. `out$slopeTemp`, *slopeTemp.tif* : An intermediate slope grid.

3. `out$slope`, *"slope.tif"* : The final slope grid, ready for modeling.

4. `out$road$lines`, *roadLines.shp* : Reprojected vector roads.

5.  `out$roadsTemp`, *"roads1.tif"* : Intermediate road raster.

6.  `out$roads`, *"roads.tif"* : Binary Roads; 1 for road, 0 not road, or NA
  outside of study area.

7. `roadClass`, *"roadClass.tif"* : Classified roads.


```{r, echo = TRUE, message = FALSE, warning = FALSE}
# Load packages
library(rasterPrep)
library(gdalUtilities)  # for ogr2ogr() used to reproject vector Shapefiles
library(terra)  # for crs() and rast() 

# Set paths for retrieving input data included with this package
input <- list(
  bound = system.file("extdata","Amherst.shp" , package = "rasterPrep"),
  slope = system.file("extdata","slope.tif" , package = "rasterPrep"), 
  roads =  system.file("extdata","roads.shp" , package = "rasterPrep"),
  key = system.file("extdata","roadClassKey.csv" , package = "rasterPrep")
)

# Output directory: you might want to replace this with a path of your choosing:
outDir <- file.path(tempdir(), "rasterPrepDemo")
dir.create(outDir, showWarnings = FALSE)

# Set output paths 
out <- list(
  ref = file.path(outDir, "reference.tif"),        # reference 
  slopeTemp = file.path(outDir, "slopeTemp.tif"),  # Intermediate slope
  slope = file.path(outDir, "slope.tif"),          # Slope
  roadLines = file.path(outDir, "roadLines.shp"),  # Reprojected vector roads
  roadsTemp = file.path(outDir, "roads1.tif"),     # Intermediate roads
  roads  = file.path(outDir, "roads.tif"),         # Binary Roads
  roadClass  = file.path(outDir, "roadClass.tif") )# Road class

# Delete output so rerunning doesn't cause problems
if(file.exists(out$roadLines))
  file.remove(list.files(outDir, "roadLines", full.names = TRUE))

for(a in setdiff(names(out), "roadLines")){
  if(file.exists(out[[a]]))
    deleteTif(out[[a]])
}
```


### 2. Create a reference raster

You may already have a raster that you would like all your other data to coincide with.  If so use that as your reference.  If you do not already have a reference raster then we can create one from a polygon that delineates a study area boundary and has the projection we would like to work in.
```{r, echo = TRUE, message = FALSE, warning = FALSE, results = FALSE}

makeReference(polyFile = input$bound, destination = out$ref, cellsize = 30)

```

Note: The optional 'alignTo' argument determines the cell alignment (AKA "snapping"); the default (`"origin"`) means that the edges of the cells will all fall on integer multiples of the cell size. If you already have some raster data in your desired projection you can also set alignTo="reference" and then set the reference argument to the path of a raster that will set the cell alignment. In this case the reference would only be used for cell alignment and not extent; allowing you to use that data without resampling or shifting the pixels. With either pixel alignment the resulting raster is going to have an extent just big enough to include all the pixels that overlap the bounds of the study area as defined in `polyFile`. 

### 3. Warp raster data to match the reference

Here we will align the sample slope data with our reference raster.  We will transform 
and crop in one step and then clip (assign NA outside of the boundary polygon) 
in a second step. Although we can combine these all in one step
the masking of pixels outside of the boundary isn't always consistent on the edges when transformation and clipping are done together.

If you don't want to clip you could just use the first step and you would retain data
for the entire rectangular extent.

Because slope is continuous we'll use the `"bilinear"` resampling method 
in the first step.  If we were working with categorical data like land cover
classes we would leave the default nearest neighbor (`"near"`) method.

```{r, echo = TRUE, message = FALSE, warning = FALSE, results = FALSE}

# Reproject to final extent, projection and alignment
warpToReference(input$slope, out$slopeTemp, reference = out$ref, 
                method = "bilinear")

# Assign NA outside of boundary
warpToReference(out$slopeTemp, out$slope, reference =  out$ref,
                clip = input$bound)

# Delete intermediate file
deleteTif(out$slopeTemp)

# Visualize
slope <- rast(out$slope)
plot(slope)

```

### 4. Rasterize vector to match the reference

Here we will first reproject the vector roads to our output projection and then 
use the result to create a roads raster that matches the reference raster.

To reproject the vector roads we are going to use the 'ogr2ogr()' function within the
gdalUtilities R package.  You could also use sf package to read in the vector data, 
reproject, and write out to a new Shapefile, but it woud be less efficient.

```{r, echo = TRUE, message = FALSE, warning = FALSE, results = FALSE}

# Reproject vector to reference projection
refProj <- terra::crs(terra::rast(out$ref))  #  well known text of projection
projFile <- file.path(outDir, "refproj.txt")
cat(refProj, file = projFile)   #well known text in file
gdalUtilities::ogr2ogr(input$roads, out$roadLines, t_srs = projFile)

```

Now we are going to rasterize the vector data using `rasterizeToReference()` from this package.
We could do this in several ways depending on what data we want in the final
raster. Importantly this function will write into any existing destination raster files
so multiple calls can be used to overlay data from different sources together
in a file.

In this first example we'll create a raster that contains the values from the 
"ROADCLASS"" attribute from the roads shapefile in cells underlying the roads 
and and NA everywhere else.

```{r, echo = TRUE, message = FALSE, warning = FALSE, results = FALSE}
rasterizeToReference(out$roadLines, destination = out$roadClass, reference = out$ref, attribute = "ROADCLASS", type = "byte")

```

Next an example where we'll create a raster with NA outside the study area 
boundary,  and 0 or 1 inside the boundary to indicate if there is a road. In this
example we'll also set `allTouched=TRUE` which will result in roads that have
orthogonal connections.

```{r, echo = TRUE, message = FALSE, warning = FALSE, results = FALSE}

# Burn in zero everywhere within the study area boundary creating a new raster file in the process
rasterizeToReference(input$bound, out$roadsTemp, reference = out$ref, 
                     burn = 0)

# Burn in 1 on top of the same raster where there are roads
rasterizeToReference(out$roadLines, destination = out$roadsTemp, allTouched = TRUE,
                     burn = 1)

# Write to new file while clipping.  Without this step road cells outside of the 
#  study boundary will have a value of 1. This re-sets them to NA.
warpToReference(out$roadsTemp, out$roads, reference = out$ref,
                clip = input$bound)

# Delete intermediate file
deleteTif(out$roadsTemp)

# Visualize
roads <- rast(out$roads)
plot(roads)
```

## II. Preparing raster files for viewing with GIS software

Here we create geoTIFF files that are suited for viewing with GIS software.
They are compressed, tiled, and have overviews (AKA pyramids).
Depending on the data contained in the file we may also add statistics,
histograms, a color table, or a Value Attribute Table (VAT).  

Tiling and overviews allow GIS software to efficiently display the data across a wide range of scales. Stats and histograms are often required to create symbology. Having all 
of these pre-calculated means that when a user opens the file they don't have to 
wait long to view it.

Everything we do here either hinders reading and processing with the **terra** 
package or adds extra files that don't help,  Do not run these functions to 
create model input. Instead run them on model output in preparation for viewing,
or distribution.

Tiling and overviews aren't necessary for the small demonstration files we are
using but make a huge difference with large datasets.  

### Setup final paths 

We are going to export to a new directory.

```{r final setup}
finalDir <- file.path(outDir, "final")
dir.create(finalDir, showWarnings = FALSE)
final <- list()
final$slope <- file.path(final,  "slope.tif")
final$road <- file.path(final,  "roads.tif")
final$roadclass <- file.path(finalDir, "roadclass.tif")
 

```



### `makeNiceTif()`

For many datasets a single call will create a copy of the input raster
that is optimized for viewing. 

The code below prepares the slope grid produced above for viewing.
Slope is continuous so we set `overviewResample="average"` so that each
overview cell will be assigned the average value of the smaller cells it
covers.

```{r, results= FALSE}
 makeNiceTif(out$slope, final$slope), 
             overviewResample = "average")
 
```



## Value Attribute Tables

A value attribute table (VAT) is a table of all the unique values in a 
raster file, the count of cells of each, value, and any additional tabular
data that is associated with each value.  It's stored in a "sidecar" file
which has the full raster name and extension plus ".vat.dbf"  so for "slope.tif"
the vat is "slope.tif.vat.dbf". 

There are two reasons you might want to add a VAT:

1.  To associate additional
information with each cell value - like the name of the landcover class.

2. Adding a vat tells GIS software that the data is categorical and it will
default to a categorical rather than gradient display when loaded. 

NOte: do not add a VAT to continous data like slope.

Here's an example where we can force categorical display without adding a 
color table by adding a VAT to the road class TIFF.

```{r}

makeNiceTif(source = out$roads, destination = final$roads, 
            overwrite = TRUE, overviewResample = "near", stats = FALSE, 
            vat = TRUE )


terra::plot(terra::rast(final$roads))

```

We'll see an example below of using a VAT to add attributes.


### Color Tables

A color table is a often desirable for categorical data like landcover.  
The color table allows us to associate a different color with 
each distinct value in a TIFF.

Unfortunately there are limitations to the format.  The TIFF must be
byte encoded and ideally every integer between 0 and the maximum value will be
used as all those values will appear in the color table. 

Despite these limitations color tables are the best way I've found to
programmatically set the color and labels for categories in a TIFF file 
from within R.

We'll demonstrate with the road class grid we created above.
First, we'll use `addColorTable()` to create a small .vrt (gdal virtual format)
file that references the tif and adds color table information. 
The .vrt file can be opened directly with ArcGIS or QGIS but we'll use it 
to create a geoTIFF that has the color table fully embedded in it.

THe key file has three colums:
  * value: the integer value used to represent the category in the TIFF.
  * category: (optional) the category name associated with each value
  * color: the hexadecimal color to display with

```{r results= FALSE}
key <- read.csv(input$key, stringsAsFactors = FALSE)  

print(key)

# Note the table must have "value", and "color" columns and can optionally 
# have a "category" column will class labels
vrt.file <- addColorTable(out$roadClass, table = key)

```

Next well encode the raster data and the color table into a new TIFF while also 
adding compression, tiling, stats, histograms, and overviews. 
The default `overviewResample`of `"near"` is appropriate for categorical data.

```{r}
finalRoadClass <- file.path(final,  "roadClass.tif")
makeNiceTif(source = vrt.file, destination = finalRoadClass, 
            overwrite = TRUE, stats = FALSE)

plot(rast(finalRoadClass))
```


Add the attribute data to the raster with the `addVat()` function.

```{r}
addVat(x = finalRoadClass, attributes = key)
```


